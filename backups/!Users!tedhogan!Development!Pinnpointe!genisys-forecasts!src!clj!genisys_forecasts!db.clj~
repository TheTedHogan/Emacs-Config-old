(ns genisys-forecasts.db
  (:require [clojure.java.jdbc :as jdbc]
            [clojure.java.io :as io]
            [honeysql.core :as sql]
            [clojure.edn :as edn]
            [hikari-cp.core :refer :all])
  (:import
           (net.sf.log4jdbc.sql.jdbcapi DataSourceSpy)))

(def ^:dynamic db (atom nil))

(def datasource-options
   (-> (io/resource "db.edn")
         (slurp)
         (edn/read-string)))

(defn setup-db []
  (reset! db (do
               (prn datasource-options)
               (println "Created DB Pool")
               {:datasource (new DataSourceSpy (make-datasource datasource-options))})))

(defn current-db []
  (:name (first (query "select db_name() as name"))))

(defn query [query]
  (jdbc/query @db query))

(defn execute! [command]
  (jdbc/execute! @db commad))

(defn in-transaction
  "Calls the provided function f in the context of a transaction on the database"
  [f]
  (jdbc/with-db-transaction [t @db]
    (binding [db (delay t)]
      (f))))

(defn set-rollback []
  (jdbc/db-set-rollback-only! @iris))

(defn unset-rollback []
  (jdbc/db-unset-rollback-only! @iris))

(defn get-rollback []
  (jdbc/db-is-rollback-only @iris))

(defn update-or-insert!
  "Updates columns or inserts a new row in the specified table"
  [table row where-clause]
  (if (zero? (first (jdbc/update! @db table row where-clause :transaction? false)))
    (do (jdbc/insert! @db table row :transaction? false) "Inserted")
    "Updated"))

(defn get-data [params]
  (let [params (->> params
                    (filter #(not (= "all" (second %))))
                    (map (fn [x] [:= (first x) (second x)]))
                    (cons [:!= :division nil])
                    (cons :and))

        sqlmap  {:select [:principal_code :principal_name
                          :division :busman
                          :Location :shipto_key
                          :customer :principalid
                          :customerid :shiptoid
                          :2014_Q1_Actual :2014_Q2_Actual
                          :2014_Q3_Actual :2014_Q4_Actual
                          :2015_Q1_Actual :2015_Q2_Actual
                          :2015_Q3_Actual :2015_Q4_Actual
                          :2014_Q1_Budget :2014_Q2_Budget
                          :2014_Q3_Budget :2014_Q4_Budget
                          :2015_Q1_Budget :2015_Q2_Budget
                          :2015_Q3_Budget :2015_Q4_Budget]
                 :from [:actual_and_budget]
                 :where params
                 :order-by [:principal_name :division
                            :customer :shipto_key]}]

    (query (sql/format sqlmap :quoting :sqlserver))))

(defn get-assignments []
  (let [sqlmap {:select [:assigned_to :assigned_by
                         :principalid :principalname
                         :shiptoid :shiptoname
                         :shiptocity :shiptostate
                         :customer :divisionname
                         :divisionid :lastmodified
                         :lastorder]
                :from [:assignments_view]
                :order-by [:principalname :divisionname
                           :customer :shiptostate]}]
    (query (sql/format sqlmap :quoting :sqlserver))))

(defn get-principals []
  (query ["select distinct principals.name as manufacturer from principals order by name"]))

(defn get-customers []
	(query ["select distinct name as customer from customergroups order by name"]))

(defn get-busmans []
	(query ["select distinct name as busman from employees where bm = 'yes' order by name "]))

(defn get-divisions []
	(query ["select distinct name as division from divisions order by name"]))

(defn convert-guid [guid]
  (let [byte-array (.getBytes guid)
        buffer (java.nio.ByteBuffer/wrap byte-array)
        high (.getLong buffer)
        low  (.getLong buffer)]
    (.toString (java.util.UUID. high low))))

(defn save-data [input, user, uuid]
  (let [webData (filter #(not (empty? (:budget %))) input)
        guid (convert-guid uuid)]
    (doseq [k webData]
      (let [budget (:budget k)
            quarter (:quarter k)
            principalID (:principalid k)
            shiptoID (:shiptoid k)]

        (jdbc/with-db-transaction [myTrans @db]
                                  (jdbc/delete! myTrans :budgets ["principal = ? AND shipto = ? AND Quarter = ?" principalID, shiptoID, quarter])
                                  (jdbc/insert! myTrans :budgets {:principal principalID
																																	:shipto shiptoID
																																	:quarter quarter
																																	:budget (clojure.string/replace budget #"[$,]" "")
																																	:set_by user
																																	:lastmodified (java.sql.Timestamp. (.getTime (java.util.Date.)))
                                                                  :GUID guid}))))))

